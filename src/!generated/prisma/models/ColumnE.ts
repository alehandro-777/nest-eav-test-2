
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ColumnE` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model ColumnE
 * 
 */
export type ColumnEModel = runtime.Types.Result.DefaultSelection<Prisma.$ColumnEPayload>

export type AggregateColumnE = {
  _count: ColumnECountAggregateOutputType | null
  _avg: ColumnEAvgAggregateOutputType | null
  _sum: ColumnESumAggregateOutputType | null
  _min: ColumnEMinAggregateOutputType | null
  _max: ColumnEMaxAggregateOutputType | null
}

export type ColumnEAvgAggregateOutputType = {
  id: number | null
  col: number | null
  tab: number | null
  typ: number | null
  ran: number | null
  kvs: number | null
}

export type ColumnESumAggregateOutputType = {
  id: number | null
  col: number | null
  tab: number | null
  typ: number | null
  ran: number | null
  kvs: number | null
}

export type ColumnEMinAggregateOutputType = {
  id: number | null
  col: number | null
  tab: number | null
  key: string | null
  name: string | null
  typ: number | null
  ran: number | null
  kvs: number | null
}

export type ColumnEMaxAggregateOutputType = {
  id: number | null
  col: number | null
  tab: number | null
  key: string | null
  name: string | null
  typ: number | null
  ran: number | null
  kvs: number | null
}

export type ColumnECountAggregateOutputType = {
  id: number
  col: number
  tab: number
  key: number
  name: number
  typ: number
  ran: number
  kvs: number
  _all: number
}


export type ColumnEAvgAggregateInputType = {
  id?: true
  col?: true
  tab?: true
  typ?: true
  ran?: true
  kvs?: true
}

export type ColumnESumAggregateInputType = {
  id?: true
  col?: true
  tab?: true
  typ?: true
  ran?: true
  kvs?: true
}

export type ColumnEMinAggregateInputType = {
  id?: true
  col?: true
  tab?: true
  key?: true
  name?: true
  typ?: true
  ran?: true
  kvs?: true
}

export type ColumnEMaxAggregateInputType = {
  id?: true
  col?: true
  tab?: true
  key?: true
  name?: true
  typ?: true
  ran?: true
  kvs?: true
}

export type ColumnECountAggregateInputType = {
  id?: true
  col?: true
  tab?: true
  key?: true
  name?: true
  typ?: true
  ran?: true
  kvs?: true
  _all?: true
}

export type ColumnEAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ColumnE to aggregate.
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ColumnES to fetch.
   */
  orderBy?: Prisma.ColumnEOrderByWithRelationInput | Prisma.ColumnEOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ColumnEWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ColumnES from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ColumnES.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ColumnES
  **/
  _count?: true | ColumnECountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ColumnEAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ColumnESumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ColumnEMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ColumnEMaxAggregateInputType
}

export type GetColumnEAggregateType<T extends ColumnEAggregateArgs> = {
      [P in keyof T & keyof AggregateColumnE]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateColumnE[P]>
    : Prisma.GetScalarType<T[P], AggregateColumnE[P]>
}




export type ColumnEGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ColumnEWhereInput
  orderBy?: Prisma.ColumnEOrderByWithAggregationInput | Prisma.ColumnEOrderByWithAggregationInput[]
  by: Prisma.ColumnEScalarFieldEnum[] | Prisma.ColumnEScalarFieldEnum
  having?: Prisma.ColumnEScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ColumnECountAggregateInputType | true
  _avg?: ColumnEAvgAggregateInputType
  _sum?: ColumnESumAggregateInputType
  _min?: ColumnEMinAggregateInputType
  _max?: ColumnEMaxAggregateInputType
}

export type ColumnEGroupByOutputType = {
  id: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran: number | null
  kvs: number | null
  _count: ColumnECountAggregateOutputType | null
  _avg: ColumnEAvgAggregateOutputType | null
  _sum: ColumnESumAggregateOutputType | null
  _min: ColumnEMinAggregateOutputType | null
  _max: ColumnEMaxAggregateOutputType | null
}

type GetColumnEGroupByPayload<T extends ColumnEGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ColumnEGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ColumnEGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ColumnEGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ColumnEGroupByOutputType[P]>
      }
    >
  >



export type ColumnEWhereInput = {
  AND?: Prisma.ColumnEWhereInput | Prisma.ColumnEWhereInput[]
  OR?: Prisma.ColumnEWhereInput[]
  NOT?: Prisma.ColumnEWhereInput | Prisma.ColumnEWhereInput[]
  id?: Prisma.IntFilter<"ColumnE"> | number
  col?: Prisma.IntFilter<"ColumnE"> | number
  tab?: Prisma.IntFilter<"ColumnE"> | number
  key?: Prisma.StringFilter<"ColumnE"> | string
  name?: Prisma.StringFilter<"ColumnE"> | string
  typ?: Prisma.IntFilter<"ColumnE"> | number
  ran?: Prisma.IntNullableFilter<"ColumnE"> | number | null
  kvs?: Prisma.IntNullableFilter<"ColumnE"> | number | null
  rows?: Prisma.RowEAVListRelationFilter
  type?: Prisma.XOR<Prisma.AttrTypeScalarRelationFilter, Prisma.AttrTypeWhereInput>
  table?: Prisma.XOR<Prisma.TableEScalarRelationFilter, Prisma.TableEWhereInput>
  range?: Prisma.XOR<Prisma.RangeNullableScalarRelationFilter, Prisma.RangeWhereInput> | null
  kVSet?: Prisma.XOR<Prisma.KVSetNullableScalarRelationFilter, Prisma.KVSetWhereInput> | null
}

export type ColumnEOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  key?: Prisma.SortOrder
  name?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrderInput | Prisma.SortOrder
  kvs?: Prisma.SortOrderInput | Prisma.SortOrder
  rows?: Prisma.RowEAVOrderByRelationAggregateInput
  type?: Prisma.AttrTypeOrderByWithRelationInput
  table?: Prisma.TableEOrderByWithRelationInput
  range?: Prisma.RangeOrderByWithRelationInput
  kVSet?: Prisma.KVSetOrderByWithRelationInput
}

export type ColumnEWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  col_tab?: Prisma.ColumnEColTabCompoundUniqueInput
  AND?: Prisma.ColumnEWhereInput | Prisma.ColumnEWhereInput[]
  OR?: Prisma.ColumnEWhereInput[]
  NOT?: Prisma.ColumnEWhereInput | Prisma.ColumnEWhereInput[]
  col?: Prisma.IntFilter<"ColumnE"> | number
  tab?: Prisma.IntFilter<"ColumnE"> | number
  key?: Prisma.StringFilter<"ColumnE"> | string
  name?: Prisma.StringFilter<"ColumnE"> | string
  typ?: Prisma.IntFilter<"ColumnE"> | number
  ran?: Prisma.IntNullableFilter<"ColumnE"> | number | null
  kvs?: Prisma.IntNullableFilter<"ColumnE"> | number | null
  rows?: Prisma.RowEAVListRelationFilter
  type?: Prisma.XOR<Prisma.AttrTypeScalarRelationFilter, Prisma.AttrTypeWhereInput>
  table?: Prisma.XOR<Prisma.TableEScalarRelationFilter, Prisma.TableEWhereInput>
  range?: Prisma.XOR<Prisma.RangeNullableScalarRelationFilter, Prisma.RangeWhereInput> | null
  kVSet?: Prisma.XOR<Prisma.KVSetNullableScalarRelationFilter, Prisma.KVSetWhereInput> | null
}, "id" | "col_tab">

export type ColumnEOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  key?: Prisma.SortOrder
  name?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrderInput | Prisma.SortOrder
  kvs?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.ColumnECountOrderByAggregateInput
  _avg?: Prisma.ColumnEAvgOrderByAggregateInput
  _max?: Prisma.ColumnEMaxOrderByAggregateInput
  _min?: Prisma.ColumnEMinOrderByAggregateInput
  _sum?: Prisma.ColumnESumOrderByAggregateInput
}

export type ColumnEScalarWhereWithAggregatesInput = {
  AND?: Prisma.ColumnEScalarWhereWithAggregatesInput | Prisma.ColumnEScalarWhereWithAggregatesInput[]
  OR?: Prisma.ColumnEScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ColumnEScalarWhereWithAggregatesInput | Prisma.ColumnEScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"ColumnE"> | number
  col?: Prisma.IntWithAggregatesFilter<"ColumnE"> | number
  tab?: Prisma.IntWithAggregatesFilter<"ColumnE"> | number
  key?: Prisma.StringWithAggregatesFilter<"ColumnE"> | string
  name?: Prisma.StringWithAggregatesFilter<"ColumnE"> | string
  typ?: Prisma.IntWithAggregatesFilter<"ColumnE"> | number
  ran?: Prisma.IntNullableWithAggregatesFilter<"ColumnE"> | number | null
  kvs?: Prisma.IntNullableWithAggregatesFilter<"ColumnE"> | number | null
}

export type ColumnECreateInput = {
  col: number
  key: string
  name: string
  rows?: Prisma.RowEAVCreateNestedManyWithoutColumnInput
  type: Prisma.AttrTypeCreateNestedOneWithoutColumnsInput
  table: Prisma.TableECreateNestedOneWithoutColumnsInput
  range?: Prisma.RangeCreateNestedOneWithoutColumnsInput
  kVSet?: Prisma.KVSetCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran?: number | null
  kvs?: number | null
  rows?: Prisma.RowEAVUncheckedCreateNestedManyWithoutColumnInput
}

export type ColumnEUpdateInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  rows?: Prisma.RowEAVUpdateManyWithoutColumnNestedInput
  type?: Prisma.AttrTypeUpdateOneRequiredWithoutColumnsNestedInput
  table?: Prisma.TableEUpdateOneRequiredWithoutColumnsNestedInput
  range?: Prisma.RangeUpdateOneWithoutColumnsNestedInput
  kVSet?: Prisma.KVSetUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  rows?: Prisma.RowEAVUncheckedUpdateManyWithoutColumnNestedInput
}

export type ColumnECreateManyInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran?: number | null
  kvs?: number | null
}

export type ColumnEUpdateManyMutationInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
}

export type ColumnEUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ColumnEListRelationFilter = {
  every?: Prisma.ColumnEWhereInput
  some?: Prisma.ColumnEWhereInput
  none?: Prisma.ColumnEWhereInput
}

export type ColumnEOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ColumnEColTabCompoundUniqueInput = {
  col: number
  tab: number
}

export type ColumnECountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  key?: Prisma.SortOrder
  name?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrder
  kvs?: Prisma.SortOrder
}

export type ColumnEAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrder
  kvs?: Prisma.SortOrder
}

export type ColumnEMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  key?: Prisma.SortOrder
  name?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrder
  kvs?: Prisma.SortOrder
}

export type ColumnEMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  key?: Prisma.SortOrder
  name?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrder
  kvs?: Prisma.SortOrder
}

export type ColumnESumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  col?: Prisma.SortOrder
  tab?: Prisma.SortOrder
  typ?: Prisma.SortOrder
  ran?: Prisma.SortOrder
  kvs?: Prisma.SortOrder
}

export type ColumnEScalarRelationFilter = {
  is?: Prisma.ColumnEWhereInput
  isNot?: Prisma.ColumnEWhereInput
}

export type ColumnECreateNestedManyWithoutKVSetInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput> | Prisma.ColumnECreateWithoutKVSetInput[] | Prisma.ColumnEUncheckedCreateWithoutKVSetInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutKVSetInput | Prisma.ColumnECreateOrConnectWithoutKVSetInput[]
  createMany?: Prisma.ColumnECreateManyKVSetInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUncheckedCreateNestedManyWithoutKVSetInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput> | Prisma.ColumnECreateWithoutKVSetInput[] | Prisma.ColumnEUncheckedCreateWithoutKVSetInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutKVSetInput | Prisma.ColumnECreateOrConnectWithoutKVSetInput[]
  createMany?: Prisma.ColumnECreateManyKVSetInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUpdateManyWithoutKVSetNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput> | Prisma.ColumnECreateWithoutKVSetInput[] | Prisma.ColumnEUncheckedCreateWithoutKVSetInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutKVSetInput | Prisma.ColumnECreateOrConnectWithoutKVSetInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutKVSetInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutKVSetInput[]
  createMany?: Prisma.ColumnECreateManyKVSetInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutKVSetInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutKVSetInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutKVSetInput | Prisma.ColumnEUpdateManyWithWhereWithoutKVSetInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnEUncheckedUpdateManyWithoutKVSetNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput> | Prisma.ColumnECreateWithoutKVSetInput[] | Prisma.ColumnEUncheckedCreateWithoutKVSetInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutKVSetInput | Prisma.ColumnECreateOrConnectWithoutKVSetInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutKVSetInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutKVSetInput[]
  createMany?: Prisma.ColumnECreateManyKVSetInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutKVSetInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutKVSetInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutKVSetInput | Prisma.ColumnEUpdateManyWithWhereWithoutKVSetInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnECreateNestedManyWithoutRangeInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput> | Prisma.ColumnECreateWithoutRangeInput[] | Prisma.ColumnEUncheckedCreateWithoutRangeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRangeInput | Prisma.ColumnECreateOrConnectWithoutRangeInput[]
  createMany?: Prisma.ColumnECreateManyRangeInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUncheckedCreateNestedManyWithoutRangeInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput> | Prisma.ColumnECreateWithoutRangeInput[] | Prisma.ColumnEUncheckedCreateWithoutRangeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRangeInput | Prisma.ColumnECreateOrConnectWithoutRangeInput[]
  createMany?: Prisma.ColumnECreateManyRangeInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUpdateManyWithoutRangeNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput> | Prisma.ColumnECreateWithoutRangeInput[] | Prisma.ColumnEUncheckedCreateWithoutRangeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRangeInput | Prisma.ColumnECreateOrConnectWithoutRangeInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutRangeInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutRangeInput[]
  createMany?: Prisma.ColumnECreateManyRangeInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutRangeInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutRangeInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutRangeInput | Prisma.ColumnEUpdateManyWithWhereWithoutRangeInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnEUncheckedUpdateManyWithoutRangeNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput> | Prisma.ColumnECreateWithoutRangeInput[] | Prisma.ColumnEUncheckedCreateWithoutRangeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRangeInput | Prisma.ColumnECreateOrConnectWithoutRangeInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutRangeInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutRangeInput[]
  createMany?: Prisma.ColumnECreateManyRangeInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutRangeInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutRangeInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutRangeInput | Prisma.ColumnEUpdateManyWithWhereWithoutRangeInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnECreateNestedManyWithoutTypeInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput> | Prisma.ColumnECreateWithoutTypeInput[] | Prisma.ColumnEUncheckedCreateWithoutTypeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTypeInput | Prisma.ColumnECreateOrConnectWithoutTypeInput[]
  createMany?: Prisma.ColumnECreateManyTypeInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUncheckedCreateNestedManyWithoutTypeInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput> | Prisma.ColumnECreateWithoutTypeInput[] | Prisma.ColumnEUncheckedCreateWithoutTypeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTypeInput | Prisma.ColumnECreateOrConnectWithoutTypeInput[]
  createMany?: Prisma.ColumnECreateManyTypeInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUpdateManyWithoutTypeNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput> | Prisma.ColumnECreateWithoutTypeInput[] | Prisma.ColumnEUncheckedCreateWithoutTypeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTypeInput | Prisma.ColumnECreateOrConnectWithoutTypeInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutTypeInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutTypeInput[]
  createMany?: Prisma.ColumnECreateManyTypeInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutTypeInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutTypeInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutTypeInput | Prisma.ColumnEUpdateManyWithWhereWithoutTypeInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnEUncheckedUpdateManyWithoutTypeNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput> | Prisma.ColumnECreateWithoutTypeInput[] | Prisma.ColumnEUncheckedCreateWithoutTypeInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTypeInput | Prisma.ColumnECreateOrConnectWithoutTypeInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutTypeInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutTypeInput[]
  createMany?: Prisma.ColumnECreateManyTypeInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutTypeInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutTypeInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutTypeInput | Prisma.ColumnEUpdateManyWithWhereWithoutTypeInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnECreateNestedManyWithoutTableInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput> | Prisma.ColumnECreateWithoutTableInput[] | Prisma.ColumnEUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTableInput | Prisma.ColumnECreateOrConnectWithoutTableInput[]
  createMany?: Prisma.ColumnECreateManyTableInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUncheckedCreateNestedManyWithoutTableInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput> | Prisma.ColumnECreateWithoutTableInput[] | Prisma.ColumnEUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTableInput | Prisma.ColumnECreateOrConnectWithoutTableInput[]
  createMany?: Prisma.ColumnECreateManyTableInputEnvelope
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
}

export type ColumnEUpdateManyWithoutTableNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput> | Prisma.ColumnECreateWithoutTableInput[] | Prisma.ColumnEUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTableInput | Prisma.ColumnECreateOrConnectWithoutTableInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutTableInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutTableInput[]
  createMany?: Prisma.ColumnECreateManyTableInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutTableInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutTableInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutTableInput | Prisma.ColumnEUpdateManyWithWhereWithoutTableInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnEUncheckedUpdateManyWithoutTableNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput> | Prisma.ColumnECreateWithoutTableInput[] | Prisma.ColumnEUncheckedCreateWithoutTableInput[]
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutTableInput | Prisma.ColumnECreateOrConnectWithoutTableInput[]
  upsert?: Prisma.ColumnEUpsertWithWhereUniqueWithoutTableInput | Prisma.ColumnEUpsertWithWhereUniqueWithoutTableInput[]
  createMany?: Prisma.ColumnECreateManyTableInputEnvelope
  set?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  disconnect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  delete?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  connect?: Prisma.ColumnEWhereUniqueInput | Prisma.ColumnEWhereUniqueInput[]
  update?: Prisma.ColumnEUpdateWithWhereUniqueWithoutTableInput | Prisma.ColumnEUpdateWithWhereUniqueWithoutTableInput[]
  updateMany?: Prisma.ColumnEUpdateManyWithWhereWithoutTableInput | Prisma.ColumnEUpdateManyWithWhereWithoutTableInput[]
  deleteMany?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
}

export type ColumnECreateNestedOneWithoutRowsInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRowsInput, Prisma.ColumnEUncheckedCreateWithoutRowsInput>
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRowsInput
  connect?: Prisma.ColumnEWhereUniqueInput
}

export type ColumnEUpdateOneRequiredWithoutRowsNestedInput = {
  create?: Prisma.XOR<Prisma.ColumnECreateWithoutRowsInput, Prisma.ColumnEUncheckedCreateWithoutRowsInput>
  connectOrCreate?: Prisma.ColumnECreateOrConnectWithoutRowsInput
  upsert?: Prisma.ColumnEUpsertWithoutRowsInput
  connect?: Prisma.ColumnEWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ColumnEUpdateToOneWithWhereWithoutRowsInput, Prisma.ColumnEUpdateWithoutRowsInput>, Prisma.ColumnEUncheckedUpdateWithoutRowsInput>
}

export type ColumnECreateWithoutKVSetInput = {
  col: number
  key: string
  name: string
  rows?: Prisma.RowEAVCreateNestedManyWithoutColumnInput
  type: Prisma.AttrTypeCreateNestedOneWithoutColumnsInput
  table: Prisma.TableECreateNestedOneWithoutColumnsInput
  range?: Prisma.RangeCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateWithoutKVSetInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran?: number | null
  rows?: Prisma.RowEAVUncheckedCreateNestedManyWithoutColumnInput
}

export type ColumnECreateOrConnectWithoutKVSetInput = {
  where: Prisma.ColumnEWhereUniqueInput
  create: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput>
}

export type ColumnECreateManyKVSetInputEnvelope = {
  data: Prisma.ColumnECreateManyKVSetInput | Prisma.ColumnECreateManyKVSetInput[]
  skipDuplicates?: boolean
}

export type ColumnEUpsertWithWhereUniqueWithoutKVSetInput = {
  where: Prisma.ColumnEWhereUniqueInput
  update: Prisma.XOR<Prisma.ColumnEUpdateWithoutKVSetInput, Prisma.ColumnEUncheckedUpdateWithoutKVSetInput>
  create: Prisma.XOR<Prisma.ColumnECreateWithoutKVSetInput, Prisma.ColumnEUncheckedCreateWithoutKVSetInput>
}

export type ColumnEUpdateWithWhereUniqueWithoutKVSetInput = {
  where: Prisma.ColumnEWhereUniqueInput
  data: Prisma.XOR<Prisma.ColumnEUpdateWithoutKVSetInput, Prisma.ColumnEUncheckedUpdateWithoutKVSetInput>
}

export type ColumnEUpdateManyWithWhereWithoutKVSetInput = {
  where: Prisma.ColumnEScalarWhereInput
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyWithoutKVSetInput>
}

export type ColumnEScalarWhereInput = {
  AND?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
  OR?: Prisma.ColumnEScalarWhereInput[]
  NOT?: Prisma.ColumnEScalarWhereInput | Prisma.ColumnEScalarWhereInput[]
  id?: Prisma.IntFilter<"ColumnE"> | number
  col?: Prisma.IntFilter<"ColumnE"> | number
  tab?: Prisma.IntFilter<"ColumnE"> | number
  key?: Prisma.StringFilter<"ColumnE"> | string
  name?: Prisma.StringFilter<"ColumnE"> | string
  typ?: Prisma.IntFilter<"ColumnE"> | number
  ran?: Prisma.IntNullableFilter<"ColumnE"> | number | null
  kvs?: Prisma.IntNullableFilter<"ColumnE"> | number | null
}

export type ColumnECreateWithoutRangeInput = {
  col: number
  key: string
  name: string
  rows?: Prisma.RowEAVCreateNestedManyWithoutColumnInput
  type: Prisma.AttrTypeCreateNestedOneWithoutColumnsInput
  table: Prisma.TableECreateNestedOneWithoutColumnsInput
  kVSet?: Prisma.KVSetCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateWithoutRangeInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  kvs?: number | null
  rows?: Prisma.RowEAVUncheckedCreateNestedManyWithoutColumnInput
}

export type ColumnECreateOrConnectWithoutRangeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  create: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput>
}

export type ColumnECreateManyRangeInputEnvelope = {
  data: Prisma.ColumnECreateManyRangeInput | Prisma.ColumnECreateManyRangeInput[]
  skipDuplicates?: boolean
}

export type ColumnEUpsertWithWhereUniqueWithoutRangeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  update: Prisma.XOR<Prisma.ColumnEUpdateWithoutRangeInput, Prisma.ColumnEUncheckedUpdateWithoutRangeInput>
  create: Prisma.XOR<Prisma.ColumnECreateWithoutRangeInput, Prisma.ColumnEUncheckedCreateWithoutRangeInput>
}

export type ColumnEUpdateWithWhereUniqueWithoutRangeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  data: Prisma.XOR<Prisma.ColumnEUpdateWithoutRangeInput, Prisma.ColumnEUncheckedUpdateWithoutRangeInput>
}

export type ColumnEUpdateManyWithWhereWithoutRangeInput = {
  where: Prisma.ColumnEScalarWhereInput
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyWithoutRangeInput>
}

export type ColumnECreateWithoutTypeInput = {
  col: number
  key: string
  name: string
  rows?: Prisma.RowEAVCreateNestedManyWithoutColumnInput
  table: Prisma.TableECreateNestedOneWithoutColumnsInput
  range?: Prisma.RangeCreateNestedOneWithoutColumnsInput
  kVSet?: Prisma.KVSetCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateWithoutTypeInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  ran?: number | null
  kvs?: number | null
  rows?: Prisma.RowEAVUncheckedCreateNestedManyWithoutColumnInput
}

export type ColumnECreateOrConnectWithoutTypeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  create: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput>
}

export type ColumnECreateManyTypeInputEnvelope = {
  data: Prisma.ColumnECreateManyTypeInput | Prisma.ColumnECreateManyTypeInput[]
  skipDuplicates?: boolean
}

export type ColumnEUpsertWithWhereUniqueWithoutTypeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  update: Prisma.XOR<Prisma.ColumnEUpdateWithoutTypeInput, Prisma.ColumnEUncheckedUpdateWithoutTypeInput>
  create: Prisma.XOR<Prisma.ColumnECreateWithoutTypeInput, Prisma.ColumnEUncheckedCreateWithoutTypeInput>
}

export type ColumnEUpdateWithWhereUniqueWithoutTypeInput = {
  where: Prisma.ColumnEWhereUniqueInput
  data: Prisma.XOR<Prisma.ColumnEUpdateWithoutTypeInput, Prisma.ColumnEUncheckedUpdateWithoutTypeInput>
}

export type ColumnEUpdateManyWithWhereWithoutTypeInput = {
  where: Prisma.ColumnEScalarWhereInput
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyWithoutTypeInput>
}

export type ColumnECreateWithoutTableInput = {
  col: number
  key: string
  name: string
  rows?: Prisma.RowEAVCreateNestedManyWithoutColumnInput
  type: Prisma.AttrTypeCreateNestedOneWithoutColumnsInput
  range?: Prisma.RangeCreateNestedOneWithoutColumnsInput
  kVSet?: Prisma.KVSetCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateWithoutTableInput = {
  id?: number
  col: number
  key: string
  name: string
  typ: number
  ran?: number | null
  kvs?: number | null
  rows?: Prisma.RowEAVUncheckedCreateNestedManyWithoutColumnInput
}

export type ColumnECreateOrConnectWithoutTableInput = {
  where: Prisma.ColumnEWhereUniqueInput
  create: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput>
}

export type ColumnECreateManyTableInputEnvelope = {
  data: Prisma.ColumnECreateManyTableInput | Prisma.ColumnECreateManyTableInput[]
  skipDuplicates?: boolean
}

export type ColumnEUpsertWithWhereUniqueWithoutTableInput = {
  where: Prisma.ColumnEWhereUniqueInput
  update: Prisma.XOR<Prisma.ColumnEUpdateWithoutTableInput, Prisma.ColumnEUncheckedUpdateWithoutTableInput>
  create: Prisma.XOR<Prisma.ColumnECreateWithoutTableInput, Prisma.ColumnEUncheckedCreateWithoutTableInput>
}

export type ColumnEUpdateWithWhereUniqueWithoutTableInput = {
  where: Prisma.ColumnEWhereUniqueInput
  data: Prisma.XOR<Prisma.ColumnEUpdateWithoutTableInput, Prisma.ColumnEUncheckedUpdateWithoutTableInput>
}

export type ColumnEUpdateManyWithWhereWithoutTableInput = {
  where: Prisma.ColumnEScalarWhereInput
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyWithoutTableInput>
}

export type ColumnECreateWithoutRowsInput = {
  col: number
  key: string
  name: string
  type: Prisma.AttrTypeCreateNestedOneWithoutColumnsInput
  table: Prisma.TableECreateNestedOneWithoutColumnsInput
  range?: Prisma.RangeCreateNestedOneWithoutColumnsInput
  kVSet?: Prisma.KVSetCreateNestedOneWithoutColumnsInput
}

export type ColumnEUncheckedCreateWithoutRowsInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran?: number | null
  kvs?: number | null
}

export type ColumnECreateOrConnectWithoutRowsInput = {
  where: Prisma.ColumnEWhereUniqueInput
  create: Prisma.XOR<Prisma.ColumnECreateWithoutRowsInput, Prisma.ColumnEUncheckedCreateWithoutRowsInput>
}

export type ColumnEUpsertWithoutRowsInput = {
  update: Prisma.XOR<Prisma.ColumnEUpdateWithoutRowsInput, Prisma.ColumnEUncheckedUpdateWithoutRowsInput>
  create: Prisma.XOR<Prisma.ColumnECreateWithoutRowsInput, Prisma.ColumnEUncheckedCreateWithoutRowsInput>
  where?: Prisma.ColumnEWhereInput
}

export type ColumnEUpdateToOneWithWhereWithoutRowsInput = {
  where?: Prisma.ColumnEWhereInput
  data: Prisma.XOR<Prisma.ColumnEUpdateWithoutRowsInput, Prisma.ColumnEUncheckedUpdateWithoutRowsInput>
}

export type ColumnEUpdateWithoutRowsInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.AttrTypeUpdateOneRequiredWithoutColumnsNestedInput
  table?: Prisma.TableEUpdateOneRequiredWithoutColumnsNestedInput
  range?: Prisma.RangeUpdateOneWithoutColumnsNestedInput
  kVSet?: Prisma.KVSetUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateWithoutRowsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ColumnECreateManyKVSetInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  ran?: number | null
}

export type ColumnEUpdateWithoutKVSetInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  rows?: Prisma.RowEAVUpdateManyWithoutColumnNestedInput
  type?: Prisma.AttrTypeUpdateOneRequiredWithoutColumnsNestedInput
  table?: Prisma.TableEUpdateOneRequiredWithoutColumnsNestedInput
  range?: Prisma.RangeUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateWithoutKVSetInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  rows?: Prisma.RowEAVUncheckedUpdateManyWithoutColumnNestedInput
}

export type ColumnEUncheckedUpdateManyWithoutKVSetInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ColumnECreateManyRangeInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  typ: number
  kvs?: number | null
}

export type ColumnEUpdateWithoutRangeInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  rows?: Prisma.RowEAVUpdateManyWithoutColumnNestedInput
  type?: Prisma.AttrTypeUpdateOneRequiredWithoutColumnsNestedInput
  table?: Prisma.TableEUpdateOneRequiredWithoutColumnsNestedInput
  kVSet?: Prisma.KVSetUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateWithoutRangeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  rows?: Prisma.RowEAVUncheckedUpdateManyWithoutColumnNestedInput
}

export type ColumnEUncheckedUpdateManyWithoutRangeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ColumnECreateManyTypeInput = {
  id?: number
  col: number
  tab: number
  key: string
  name: string
  ran?: number | null
  kvs?: number | null
}

export type ColumnEUpdateWithoutTypeInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  rows?: Prisma.RowEAVUpdateManyWithoutColumnNestedInput
  table?: Prisma.TableEUpdateOneRequiredWithoutColumnsNestedInput
  range?: Prisma.RangeUpdateOneWithoutColumnsNestedInput
  kVSet?: Prisma.KVSetUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateWithoutTypeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  rows?: Prisma.RowEAVUncheckedUpdateManyWithoutColumnNestedInput
}

export type ColumnEUncheckedUpdateManyWithoutTypeInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  tab?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ColumnECreateManyTableInput = {
  id?: number
  col: number
  key: string
  name: string
  typ: number
  ran?: number | null
  kvs?: number | null
}

export type ColumnEUpdateWithoutTableInput = {
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  rows?: Prisma.RowEAVUpdateManyWithoutColumnNestedInput
  type?: Prisma.AttrTypeUpdateOneRequiredWithoutColumnsNestedInput
  range?: Prisma.RangeUpdateOneWithoutColumnsNestedInput
  kVSet?: Prisma.KVSetUpdateOneWithoutColumnsNestedInput
}

export type ColumnEUncheckedUpdateWithoutTableInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  rows?: Prisma.RowEAVUncheckedUpdateManyWithoutColumnNestedInput
}

export type ColumnEUncheckedUpdateManyWithoutTableInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  col?: Prisma.IntFieldUpdateOperationsInput | number
  key?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  typ?: Prisma.IntFieldUpdateOperationsInput | number
  ran?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  kvs?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}


/**
 * Count Type ColumnECountOutputType
 */

export type ColumnECountOutputType = {
  rows: number
}

export type ColumnECountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  rows?: boolean | ColumnECountOutputTypeCountRowsArgs
}

/**
 * ColumnECountOutputType without action
 */
export type ColumnECountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnECountOutputType
   */
  select?: Prisma.ColumnECountOutputTypeSelect<ExtArgs> | null
}

/**
 * ColumnECountOutputType without action
 */
export type ColumnECountOutputTypeCountRowsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RowEAVWhereInput
}


export type ColumnESelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  col?: boolean
  tab?: boolean
  key?: boolean
  name?: boolean
  typ?: boolean
  ran?: boolean
  kvs?: boolean
  rows?: boolean | Prisma.ColumnE$rowsArgs<ExtArgs>
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
  _count?: boolean | Prisma.ColumnECountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["columnE"]>

export type ColumnESelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  col?: boolean
  tab?: boolean
  key?: boolean
  name?: boolean
  typ?: boolean
  ran?: boolean
  kvs?: boolean
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
}, ExtArgs["result"]["columnE"]>

export type ColumnESelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  col?: boolean
  tab?: boolean
  key?: boolean
  name?: boolean
  typ?: boolean
  ran?: boolean
  kvs?: boolean
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
}, ExtArgs["result"]["columnE"]>

export type ColumnESelectScalar = {
  id?: boolean
  col?: boolean
  tab?: boolean
  key?: boolean
  name?: boolean
  typ?: boolean
  ran?: boolean
  kvs?: boolean
}

export type ColumnEOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "col" | "tab" | "key" | "name" | "typ" | "ran" | "kvs", ExtArgs["result"]["columnE"]>
export type ColumnEInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  rows?: boolean | Prisma.ColumnE$rowsArgs<ExtArgs>
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
  _count?: boolean | Prisma.ColumnECountOutputTypeDefaultArgs<ExtArgs>
}
export type ColumnEIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
}
export type ColumnEIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  type?: boolean | Prisma.AttrTypeDefaultArgs<ExtArgs>
  table?: boolean | Prisma.TableEDefaultArgs<ExtArgs>
  range?: boolean | Prisma.ColumnE$rangeArgs<ExtArgs>
  kVSet?: boolean | Prisma.ColumnE$kVSetArgs<ExtArgs>
}

export type $ColumnEPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ColumnE"
  objects: {
    rows: Prisma.$RowEAVPayload<ExtArgs>[]
    type: Prisma.$AttrTypePayload<ExtArgs>
    table: Prisma.$TableEPayload<ExtArgs>
    range: Prisma.$RangePayload<ExtArgs> | null
    kVSet: Prisma.$KVSetPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    col: number
    tab: number
    key: string
    name: string
    typ: number
    ran: number | null
    kvs: number | null
  }, ExtArgs["result"]["columnE"]>
  composites: {}
}

export type ColumnEGetPayload<S extends boolean | null | undefined | ColumnEDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ColumnEPayload, S>

export type ColumnECountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ColumnEFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ColumnECountAggregateInputType | true
  }

export interface ColumnEDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ColumnE'], meta: { name: 'ColumnE' } }
  /**
   * Find zero or one ColumnE that matches the filter.
   * @param {ColumnEFindUniqueArgs} args - Arguments to find a ColumnE
   * @example
   * // Get one ColumnE
   * const columnE = await prisma.columnE.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ColumnEFindUniqueArgs>(args: Prisma.SelectSubset<T, ColumnEFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ColumnE that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ColumnEFindUniqueOrThrowArgs} args - Arguments to find a ColumnE
   * @example
   * // Get one ColumnE
   * const columnE = await prisma.columnE.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ColumnEFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ColumnEFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ColumnE that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEFindFirstArgs} args - Arguments to find a ColumnE
   * @example
   * // Get one ColumnE
   * const columnE = await prisma.columnE.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ColumnEFindFirstArgs>(args?: Prisma.SelectSubset<T, ColumnEFindFirstArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ColumnE that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEFindFirstOrThrowArgs} args - Arguments to find a ColumnE
   * @example
   * // Get one ColumnE
   * const columnE = await prisma.columnE.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ColumnEFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ColumnEFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ColumnES that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ColumnES
   * const columnES = await prisma.columnE.findMany()
   * 
   * // Get first 10 ColumnES
   * const columnES = await prisma.columnE.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const columnEWithIdOnly = await prisma.columnE.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ColumnEFindManyArgs>(args?: Prisma.SelectSubset<T, ColumnEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ColumnE.
   * @param {ColumnECreateArgs} args - Arguments to create a ColumnE.
   * @example
   * // Create one ColumnE
   * const ColumnE = await prisma.columnE.create({
   *   data: {
   *     // ... data to create a ColumnE
   *   }
   * })
   * 
   */
  create<T extends ColumnECreateArgs>(args: Prisma.SelectSubset<T, ColumnECreateArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ColumnES.
   * @param {ColumnECreateManyArgs} args - Arguments to create many ColumnES.
   * @example
   * // Create many ColumnES
   * const columnE = await prisma.columnE.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ColumnECreateManyArgs>(args?: Prisma.SelectSubset<T, ColumnECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ColumnES and returns the data saved in the database.
   * @param {ColumnECreateManyAndReturnArgs} args - Arguments to create many ColumnES.
   * @example
   * // Create many ColumnES
   * const columnE = await prisma.columnE.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ColumnES and only return the `id`
   * const columnEWithIdOnly = await prisma.columnE.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ColumnECreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ColumnECreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ColumnE.
   * @param {ColumnEDeleteArgs} args - Arguments to delete one ColumnE.
   * @example
   * // Delete one ColumnE
   * const ColumnE = await prisma.columnE.delete({
   *   where: {
   *     // ... filter to delete one ColumnE
   *   }
   * })
   * 
   */
  delete<T extends ColumnEDeleteArgs>(args: Prisma.SelectSubset<T, ColumnEDeleteArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ColumnE.
   * @param {ColumnEUpdateArgs} args - Arguments to update one ColumnE.
   * @example
   * // Update one ColumnE
   * const columnE = await prisma.columnE.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ColumnEUpdateArgs>(args: Prisma.SelectSubset<T, ColumnEUpdateArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ColumnES.
   * @param {ColumnEDeleteManyArgs} args - Arguments to filter ColumnES to delete.
   * @example
   * // Delete a few ColumnES
   * const { count } = await prisma.columnE.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ColumnEDeleteManyArgs>(args?: Prisma.SelectSubset<T, ColumnEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ColumnES.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ColumnES
   * const columnE = await prisma.columnE.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ColumnEUpdateManyArgs>(args: Prisma.SelectSubset<T, ColumnEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ColumnES and returns the data updated in the database.
   * @param {ColumnEUpdateManyAndReturnArgs} args - Arguments to update many ColumnES.
   * @example
   * // Update many ColumnES
   * const columnE = await prisma.columnE.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ColumnES and only return the `id`
   * const columnEWithIdOnly = await prisma.columnE.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ColumnEUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ColumnEUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ColumnE.
   * @param {ColumnEUpsertArgs} args - Arguments to update or create a ColumnE.
   * @example
   * // Update or create a ColumnE
   * const columnE = await prisma.columnE.upsert({
   *   create: {
   *     // ... data to create a ColumnE
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ColumnE we want to update
   *   }
   * })
   */
  upsert<T extends ColumnEUpsertArgs>(args: Prisma.SelectSubset<T, ColumnEUpsertArgs<ExtArgs>>): Prisma.Prisma__ColumnEClient<runtime.Types.Result.GetResult<Prisma.$ColumnEPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ColumnES.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnECountArgs} args - Arguments to filter ColumnES to count.
   * @example
   * // Count the number of ColumnES
   * const count = await prisma.columnE.count({
   *   where: {
   *     // ... the filter for the ColumnES we want to count
   *   }
   * })
  **/
  count<T extends ColumnECountArgs>(
    args?: Prisma.Subset<T, ColumnECountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ColumnECountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ColumnE.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ColumnEAggregateArgs>(args: Prisma.Subset<T, ColumnEAggregateArgs>): Prisma.PrismaPromise<GetColumnEAggregateType<T>>

  /**
   * Group by ColumnE.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ColumnEGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ColumnEGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ColumnEGroupByArgs['orderBy'] }
      : { orderBy?: ColumnEGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ColumnEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColumnEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ColumnE model
 */
readonly fields: ColumnEFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ColumnE.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ColumnEClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  rows<T extends Prisma.ColumnE$rowsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ColumnE$rowsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RowEAVPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  type<T extends Prisma.AttrTypeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.AttrTypeDefaultArgs<ExtArgs>>): Prisma.Prisma__AttrTypeClient<runtime.Types.Result.GetResult<Prisma.$AttrTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  table<T extends Prisma.TableEDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TableEDefaultArgs<ExtArgs>>): Prisma.Prisma__TableEClient<runtime.Types.Result.GetResult<Prisma.$TableEPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  range<T extends Prisma.ColumnE$rangeArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ColumnE$rangeArgs<ExtArgs>>): Prisma.Prisma__RangeClient<runtime.Types.Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  kVSet<T extends Prisma.ColumnE$kVSetArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ColumnE$kVSetArgs<ExtArgs>>): Prisma.Prisma__KVSetClient<runtime.Types.Result.GetResult<Prisma.$KVSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ColumnE model
 */
export interface ColumnEFieldRefs {
  readonly id: Prisma.FieldRef<"ColumnE", 'Int'>
  readonly col: Prisma.FieldRef<"ColumnE", 'Int'>
  readonly tab: Prisma.FieldRef<"ColumnE", 'Int'>
  readonly key: Prisma.FieldRef<"ColumnE", 'String'>
  readonly name: Prisma.FieldRef<"ColumnE", 'String'>
  readonly typ: Prisma.FieldRef<"ColumnE", 'Int'>
  readonly ran: Prisma.FieldRef<"ColumnE", 'Int'>
  readonly kvs: Prisma.FieldRef<"ColumnE", 'Int'>
}
    

// Custom InputTypes
/**
 * ColumnE findUnique
 */
export type ColumnEFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter, which ColumnE to fetch.
   */
  where: Prisma.ColumnEWhereUniqueInput
}

/**
 * ColumnE findUniqueOrThrow
 */
export type ColumnEFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter, which ColumnE to fetch.
   */
  where: Prisma.ColumnEWhereUniqueInput
}

/**
 * ColumnE findFirst
 */
export type ColumnEFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter, which ColumnE to fetch.
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ColumnES to fetch.
   */
  orderBy?: Prisma.ColumnEOrderByWithRelationInput | Prisma.ColumnEOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ColumnES.
   */
  cursor?: Prisma.ColumnEWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ColumnES from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ColumnES.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ColumnES.
   */
  distinct?: Prisma.ColumnEScalarFieldEnum | Prisma.ColumnEScalarFieldEnum[]
}

/**
 * ColumnE findFirstOrThrow
 */
export type ColumnEFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter, which ColumnE to fetch.
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ColumnES to fetch.
   */
  orderBy?: Prisma.ColumnEOrderByWithRelationInput | Prisma.ColumnEOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ColumnES.
   */
  cursor?: Prisma.ColumnEWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ColumnES from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ColumnES.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ColumnES.
   */
  distinct?: Prisma.ColumnEScalarFieldEnum | Prisma.ColumnEScalarFieldEnum[]
}

/**
 * ColumnE findMany
 */
export type ColumnEFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter, which ColumnES to fetch.
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ColumnES to fetch.
   */
  orderBy?: Prisma.ColumnEOrderByWithRelationInput | Prisma.ColumnEOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ColumnES.
   */
  cursor?: Prisma.ColumnEWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ColumnES from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ColumnES.
   */
  skip?: number
  distinct?: Prisma.ColumnEScalarFieldEnum | Prisma.ColumnEScalarFieldEnum[]
}

/**
 * ColumnE create
 */
export type ColumnECreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * The data needed to create a ColumnE.
   */
  data: Prisma.XOR<Prisma.ColumnECreateInput, Prisma.ColumnEUncheckedCreateInput>
}

/**
 * ColumnE createMany
 */
export type ColumnECreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ColumnES.
   */
  data: Prisma.ColumnECreateManyInput | Prisma.ColumnECreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ColumnE createManyAndReturn
 */
export type ColumnECreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * The data used to create many ColumnES.
   */
  data: Prisma.ColumnECreateManyInput | Prisma.ColumnECreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ColumnE update
 */
export type ColumnEUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * The data needed to update a ColumnE.
   */
  data: Prisma.XOR<Prisma.ColumnEUpdateInput, Prisma.ColumnEUncheckedUpdateInput>
  /**
   * Choose, which ColumnE to update.
   */
  where: Prisma.ColumnEWhereUniqueInput
}

/**
 * ColumnE updateMany
 */
export type ColumnEUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ColumnES.
   */
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyInput>
  /**
   * Filter which ColumnES to update
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * Limit how many ColumnES to update.
   */
  limit?: number
}

/**
 * ColumnE updateManyAndReturn
 */
export type ColumnEUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * The data used to update ColumnES.
   */
  data: Prisma.XOR<Prisma.ColumnEUpdateManyMutationInput, Prisma.ColumnEUncheckedUpdateManyInput>
  /**
   * Filter which ColumnES to update
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * Limit how many ColumnES to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ColumnE upsert
 */
export type ColumnEUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * The filter to search for the ColumnE to update in case it exists.
   */
  where: Prisma.ColumnEWhereUniqueInput
  /**
   * In case the ColumnE found by the `where` argument doesn't exist, create a new ColumnE with this data.
   */
  create: Prisma.XOR<Prisma.ColumnECreateInput, Prisma.ColumnEUncheckedCreateInput>
  /**
   * In case the ColumnE was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ColumnEUpdateInput, Prisma.ColumnEUncheckedUpdateInput>
}

/**
 * ColumnE delete
 */
export type ColumnEDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
  /**
   * Filter which ColumnE to delete.
   */
  where: Prisma.ColumnEWhereUniqueInput
}

/**
 * ColumnE deleteMany
 */
export type ColumnEDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ColumnES to delete
   */
  where?: Prisma.ColumnEWhereInput
  /**
   * Limit how many ColumnES to delete.
   */
  limit?: number
}

/**
 * ColumnE.rows
 */
export type ColumnE$rowsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RowEAV
   */
  select?: Prisma.RowEAVSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RowEAV
   */
  omit?: Prisma.RowEAVOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RowEAVInclude<ExtArgs> | null
  where?: Prisma.RowEAVWhereInput
  orderBy?: Prisma.RowEAVOrderByWithRelationInput | Prisma.RowEAVOrderByWithRelationInput[]
  cursor?: Prisma.RowEAVWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.RowEAVScalarFieldEnum | Prisma.RowEAVScalarFieldEnum[]
}

/**
 * ColumnE.range
 */
export type ColumnE$rangeArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Range
   */
  select?: Prisma.RangeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Range
   */
  omit?: Prisma.RangeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RangeInclude<ExtArgs> | null
  where?: Prisma.RangeWhereInput
}

/**
 * ColumnE.kVSet
 */
export type ColumnE$kVSetArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KVSet
   */
  select?: Prisma.KVSetSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KVSet
   */
  omit?: Prisma.KVSetOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KVSetInclude<ExtArgs> | null
  where?: Prisma.KVSetWhereInput
}

/**
 * ColumnE without action
 */
export type ColumnEDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ColumnE
   */
  select?: Prisma.ColumnESelect<ExtArgs> | null
  /**
   * Omit specific fields from the ColumnE
   */
  omit?: Prisma.ColumnEOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ColumnEInclude<ExtArgs> | null
}
